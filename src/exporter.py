import os
import re
import msgpack # Format binaire ultra-rapide
from .models import RuleVector

class Exporter:
    def __init__(self, output_dir):
        self.output_dir = output_dir
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)

    def export_all(self, firewall_rules, inspection_rules):
        print(f"[*] Démarrage de l'exportation vers {self.output_dir}...")
        
        # 1. Export iptables (Fast Path)
        self._export_iptables(firewall_rules, "firewall.sh")
        
        # 2. Export Hyperscan (Deep Path - Patterns)
        # On doit d'abord mapper les règles à des IDs uniques pour Hyperscan
        hs_map = self._prepare_hyperscan_map(inspection_rules)
        self._export_hyperscan_patterns(hs_map, "patterns.txt")
        
        # 3. Export Binaire Contextuel (Deep Path - Logique IP/Port -> Pattern ID)
        self._export_binary_config(inspection_rules, hs_map, "rules_config.msgpack")
        
        print("[*] Exportation terminée avec succès.")

    def _export_iptables(self, rules: list[RuleVector], filename):
        """
        Génère un script bash pour iptables.
        Crée une chaîne dédiée pour une gestion propre.
        """
        path = os.path.join(self.output_dir, filename)
        with open(path, 'w') as f:
            f.write("#!/bin/bash\n")
            f.write("# Generated by Fox Optimizer - Pure Firewall Rules\n\n")
            
            # Setup de la chaîne
            f.write("# 1. Setup Chain\n")
            f.write("iptables -N FOX_FILTER 2>/dev/null\n")
            f.write("iptables -F FOX_FILTER\n")
            f.write("iptables -I INPUT -j FOX_FILTER\n\n")
            
            f.write(f"# 2. Injecting {len(rules)} Optimized Rules\n")
            
            for r in rules:
                cmd = "iptables -A FOX_FILTER"
                
                # Proto
                cmd += f" -p {r.proto}"
                
                # IPs (On prend le premier CIDR si fusionné, ou on boucle si multiples)
                # Pour iptables standard, on doit générer une ligne par CIDR si pas ipset.
                # Pour la PoC, on génère une commande par combinaison Src/Dst majeure.
                
                # Note: Optimisation possible -> utiliser 'ipset' pour les listes d'IPs.
                # Ici, on fait simple : boucle sur les CIDR sources.
                
                srcs = [str(c) for c in r.src_ips.iter_cidrs()]
                dsts = [str(c) for c in r.dst_ips.iter_cidrs()]
                
                # Attention à l'explosion de lignes ici si on a fusionné 1000 IPs.
                # C'est là qu'ipset serait mieux, mais restons sur iptables pur pour la portabilité.
                for src in srcs:
                    # Gestion Ports
                    # iptables gère --dport start:end
                    dports = []
                    for p in r.dst_ports.iter_cidrs(): # IPRange
                        # p est un IPRange ou IPNetwork, on veut start:end
                        if hasattr(p, 'first') and hasattr(p, 'last'):
                            if p.first == p.last: dports.append(str(p.first))
                            else: dports.append(f"{p.first}:{p.last}")
                        else:
                            # Fallback
                            dports.append(str(p).split('/')[-1]) # Hacky but works for single ints

                    # Construction commande de base
                    base_cmd = cmd + f" -s {src}"
                    
                    # Flags TCP (Sécurité)
                    if r.tcp_flags:
                        # flags:S souvent noté "SYN" dans iptables ou "--tcp-flags ALL SYN"
                        # On simplifie pour la PoC : si S, on met --syn
                        if "S" in r.tcp_flags:
                            base_cmd += " --syn"
                    
                    # ICMP Type
                    if r.icmp_type:
                        base_cmd += f" --icmp-type {r.icmp_type}"

                    # Action
                    action = "DROP" if r.action in ["drop", "reject"] else "LOG"
                    
                    # Émission des commandes pour chaque port (ou multiport si supporté)
                    # On utilise multiport pour réduire le nombre de lignes
                    if len(dports) > 0:
                        # iptables multiport max 15 ports. On chunk.
                        chunk_size = 15
                        for i in range(0, len(dports), chunk_size):
                            chunk = ",".join(dports[i:i+chunk_size])
                            f.write(f"{base_cmd} -m multiport --dports {chunk} -j {action}\n")
                    else:
                        # Pas de port spécifié (tous ports)
                        f.write(f"{base_cmd} -j {action}\n")

        # Rendre exécutable
        try:
            os.chmod(path, 0o755)
        except: pass
        print(f"    -> Généré : {filename}")

    def _prepare_hyperscan_map(self, rules: list[RuleVector]):
        """
        Associe chaque règle d'inspection à un ID unique pour Hyperscan.
        Retourne une map {rule_id: {'hs_id': int, 'patterns': list[str]}}
        """
        hs_map = {}
        hs_counter = 1
        
        for r in rules:
            # On génère un ID pour le groupe de patterns de cette règle
            current_hs_id = hs_counter
            hs_counter += 1
            
            # Conversion des patterns en regex compatibles Hyperscan
            regex_list = []
            for p in r.patterns:
                regex = p.string_val
                
                # 1. Conversion Hex |0A| -> \x0A
                if '|' in regex:
                    regex = re.sub(r'\|([0-9A-Fa-f\s]+)\|', 
                                   lambda m: ''.join([f'\\x{b}' for b in m.group(1).split()]), 
                                   regex)
                
                # 2. Echappement si ce n'est pas déjà une regex (content simple)
                if not p.is_regex:
                    regex = re.escape(regex)
                
                # 3. Modifiers (nocase) -> (?i)
                # Pattern Hyperscan: ID:/regex/flags
                # On gérera les flags dans le fichier
                regex_entry = {
                    'expr': regex,
                    'flags': 'i' if 'nocase' in str(p.modifiers) else '' # Simplification parsing modifiers
                }
                regex_list.append(regex_entry)
            
            hs_map[r.id] = {
                'hs_id': current_hs_id,
                'regex_list': regex_list
            }
            
        return hs_map

    def _export_hyperscan_patterns(self, hs_map, filename):
        """
        Génère le fichier patterns.txt pour le compilateur Hyperscan.
        Format: ID:/regex/flags
        """
        path = os.path.join(self.output_dir, filename)
        with open(path, 'w') as f:
            for rule_id, data in hs_map.items():
                hs_id = data['hs_id']
                for regex_entry in data['regex_list']:
                    expr = regex_entry['expr']
                    flags = regex_entry['flags']
                    # Format Hyperscan standard
                    # ID:/regex/flags
                    # Attention aux slashs dans la regex, il faut les échapper pour ce format fichier
                    safe_expr = expr.replace('/', '\\/')
                    f.write(f"{hs_id}:/{safe_expr}/{flags}\n")
        print(f"    -> Généré : {filename}")

    def _export_binary_config(self, rules: list[RuleVector], hs_map, filename):
        """
        Sérialise la structure logique en MessagePack pour le C++.
        Contient : IP Src/Dst, Ports, Proto -> Lien vers ID Hyperscan.
        """
        path = os.path.join(self.output_dir, filename)
        
        data_to_serialize = []
        
        for r in rules:
            # On convertit les IPSets et PortSets en listes primitives (strings/ints)
            # pour que le C++ puisse les lire facilement.
            
            src_cidrs = [str(c) for c in r.src_ips.iter_cidrs()]
            dst_cidrs = [str(c) for c in r.dst_ips.iter_cidrs()]
            
            src_ports = []
            for p in r.src_ports.iter_cidrs():
                if hasattr(p, 'first'): src_ports.append([p.first, p.last])
                
            dst_ports = []
            for p in r.dst_ports.iter_cidrs():
                if hasattr(p, 'first'): dst_ports.append([p.first, p.last])

            # Lien vers Hyperscan
            hs_id = hs_map[r.id]['hs_id']
            
            # Structure de l'objet binaire
            rule_obj = {
                'id': r.id,
                'proto': r.proto,
                'src_ips': src_cidrs,
                'dst_ips': dst_cidrs,
                'src_ports': src_ports,
                'dst_ports': dst_ports,
                'direction': r.direction,
                'hs_id': hs_id, # Le lien vital !
                'action': r.action
            }
            data_to_serialize.append(rule_obj)
            
        with open(path, 'wb') as f:
            packed = msgpack.packb(data_to_serialize)
            f.write(packed)
            
        print(f"    -> Généré : {filename} ({len(packed)/1024:.2f} KB)")