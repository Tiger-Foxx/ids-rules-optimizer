import os
import re
import msgpack # Format binaire ultra-rapide
from .models import RuleVector

class Exporter:
    def __init__(self, output_dir):
        self.output_dir = output_dir
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)

    def export_all(self, firewall_rules, inspection_rules):
        print(f"[*] Démarrage de l'exportation vers {self.output_dir}...")
        
        # 1. Export iptables (Fast Path)
        self._export_iptables(firewall_rules, "firewall.sh")
        
        # 2. Export Hyperscan (Deep Path - Patterns)
        # On doit d'abord mapper les règles à des IDs uniques pour Hyperscan
        hs_map = self._prepare_hyperscan_map(inspection_rules)
        self._export_hyperscan_patterns(hs_map, "patterns.txt")
        
        # 3. Export Binaire Contextuel (Deep Path - Logique IP/Port -> Pattern ID)
        self._export_binary_config(inspection_rules, hs_map, "rules_config.msgpack")
        
        print("[*] Exportation terminée avec succès.")

    def _export_iptables(self, rules: list[RuleVector], filename):
        """
        Génère un script bash pour iptables + ipset.
        
        OPTIMISATION AVANCÉE:
        1. Détecte les ensembles d'IPs identiques entre règles
        2. Crée un ipset partagé par ensemble unique
        3. Réutilise l'ipset pour toutes les règles qui le partagent
        """
        path = os.path.join(self.output_dir, filename)
        
        # Phase 1: Identifier les ensembles d'IPs uniques
        # Clé = tuple trié des CIDRs, Valeur = nom de l'ipset
        unique_ipsets = {}
        ipset_counter = 0
        rule_to_ipset = {}  # rule_index -> ipset_name (ou None si simple)
        
        for idx, r in enumerate(rules):
            srcs = tuple(sorted(str(c) for c in r.src_ips.iter_cidrs()))
            
            if len(srcs) > 3:
                if srcs not in unique_ipsets:
                    ipset_name = f"fox_set{ipset_counter}"
                    unique_ipsets[srcs] = ipset_name
                    ipset_counter += 1
                rule_to_ipset[idx] = unique_ipsets[srcs]
            else:
                rule_to_ipset[idx] = None
        
        with open(path, 'w') as f:
            f.write("#!/bin/bash\n")
            f.write("# Generated by Fox Optimizer - Pure Firewall Rules\n")
            f.write("# IMPORTANT: Run as root! Requires ipset package.\n\n")
            
            # Setup de la chaîne
            f.write("# 1. Setup Chain\n")
            f.write("iptables -N FOX_FILTER 2>/dev/null\n")
            f.write("iptables -F FOX_FILTER\n")
            f.write("iptables -D INPUT -j FOX_FILTER 2>/dev/null\n")
            f.write("iptables -I INPUT -j FOX_FILTER\n\n")
            
            # Phase 2: Créer les ipsets uniques (une seule fois chacun)
            if unique_ipsets:
                f.write(f"# 2. Creating {len(unique_ipsets)} shared IP sets\n")
                for cidrs, ipset_name in unique_ipsets.items():
                    f.write(f"ipset destroy {ipset_name} 2>/dev/null\n")
                    f.write(f"ipset create {ipset_name} hash:net\n")
                    for cidr in cidrs:
                        f.write(f"ipset add {ipset_name} {cidr}\n")
                    f.write("\n")
            
            # Phase 3: Générer les règles iptables
            f.write(f"# 3. Injecting {len(rules)} Firewall Rules\n")
            
            for idx, r in enumerate(rules):
                proto = r.proto.lower()
                if proto == "ip" or proto == "any":
                    proto_flag = ""
                else:
                    proto_flag = f" -p {proto}"
                
                # Gestion Ports Destination
                dports = []
                for p in r.dst_ports.iter_cidrs():
                    if hasattr(p, 'first') and hasattr(p, 'last'):
                        if p.first == 0 and p.last == 65535:
                            continue
                        elif p.first == p.last:
                            dports.append(str(p.first))
                        else:
                            dports.append(f"{p.first}:{p.last}")
                
                action = "DROP"
                ipset_name = rule_to_ipset[idx]
                
                if ipset_name:
                    # Utiliser l'ipset partagé
                    base_cmd = f"iptables -A FOX_FILTER{proto_flag} -m set --match-set {ipset_name} src"
                    
                    if r.icmp_type and proto == "icmp":
                        base_cmd += f" --icmp-type {r.icmp_type}"
                    
                    if r.tcp_flags and proto == "tcp":
                        if "S" in r.tcp_flags and "A" not in r.tcp_flags:
                            base_cmd += " --syn"
                    
                    if dports and proto in ["tcp", "udp"]:
                        chunk_size = 15
                        for i in range(0, len(dports), chunk_size):
                            chunk = ",".join(dports[i:i+chunk_size])
                            f.write(f"{base_cmd} -m multiport --dports {chunk} -j {action}\n")
                    else:
                        f.write(f"{base_cmd} -j {action}\n")
                else:
                    # Règles simples (peu de CIDRs)
                    srcs = [str(c) for c in r.src_ips.iter_cidrs()]
                    for src in srcs:
                        base_cmd = f"iptables -A FOX_FILTER{proto_flag}"
                        
                        if src != "0.0.0.0/0":
                            base_cmd += f" -s {src}"
                        
                        if r.tcp_flags and proto == "tcp":
                            if "S" in r.tcp_flags and "A" not in r.tcp_flags:
                                base_cmd += " --syn"
                        
                        if r.icmp_type and proto == "icmp":
                            base_cmd += f" --icmp-type {r.icmp_type}"
                        
                        if dports and proto in ["tcp", "udp"]:
                            chunk_size = 15
                            for i in range(0, len(dports), chunk_size):
                                chunk = ",".join(dports[i:i+chunk_size])
                                f.write(f"{base_cmd} -m multiport --dports {chunk} -j {action}\n")
                        else:
                            f.write(f"{base_cmd} -j {action}\n")

        try:
            os.chmod(path, 0o755)
        except: pass
        
        stats = f"{len(rules)} règles, {len(unique_ipsets)} ipsets partagés"
        print(f"    -> Généré : {filename} ({stats})")

    def _prepare_hyperscan_map(self, rules: list[RuleVector]):
        """
        Associe chaque règle d'inspection à un ID unique pour Hyperscan.
        Retourne une map {rule_id: {'hs_id': int, 'patterns': list[str]}}
        """
        hs_map = {}
        hs_counter = 1
        
        for r in rules:
            # On génère un ID pour le groupe de patterns de cette règle
            current_hs_id = hs_counter
            hs_counter += 1
            
            # Conversion des patterns en regex compatibles Hyperscan
            regex_list = []
            for p in r.patterns:
                regex = p.string_val
                
                # 1. Conversion Hex |0A| -> \x0A
                if '|' in regex:
                    regex = re.sub(r'\|([0-9A-Fa-f\s]+)\|', 
                                   lambda m: ''.join([f'\\x{b}' for b in m.group(1).split()]), 
                                   regex)
                
                # 2. Echappement si ce n'est pas déjà une regex (content simple)
                if not p.is_regex:
                    regex = re.escape(regex)
                
                # 3. Modifiers (nocase) -> (?i)
                # Pattern Hyperscan: ID:/regex/flags
                # On gérera les flags dans le fichier
                regex_entry = {
                    'expr': regex,
                    'flags': 'i' if 'nocase' in str(p.modifiers) else '' # Simplification parsing modifiers
                }
                regex_list.append(regex_entry)
            
            hs_map[r.id] = {
                'hs_id': current_hs_id,
                'regex_list': regex_list
            }
            
        return hs_map

    def _export_hyperscan_patterns(self, hs_map, filename):
        """
        Génère le fichier patterns.txt pour le compilateur Hyperscan.
        Format: ID:/regex/flags
        """
        path = os.path.join(self.output_dir, filename)
        with open(path, 'w') as f:
            for rule_id, data in hs_map.items():
                hs_id = data['hs_id']
                for regex_entry in data['regex_list']:
                    expr = regex_entry['expr']
                    flags = regex_entry['flags']
                    # Format Hyperscan standard
                    # ID:/regex/flags
                    # Attention aux slashs dans la regex, il faut les échapper pour ce format fichier
                    safe_expr = expr.replace('/', '\\/')
                    f.write(f"{hs_id}:/{safe_expr}/{flags}\n")
        print(f"    -> Généré : {filename}")

    def _export_binary_config(self, rules: list[RuleVector], hs_map, filename):
        """
        Sérialise la structure logique en MessagePack pour le C++.
        Contient : IP Src/Dst, Ports, Proto -> Lien vers ID Hyperscan.
        """
        path = os.path.join(self.output_dir, filename)
        
        data_to_serialize = []
        
        for r in rules:
            # On convertit les IPSets et PortSets en listes primitives (strings/ints)
            # pour que le C++ puisse les lire facilement.
            
            src_cidrs = [str(c) for c in r.src_ips.iter_cidrs()]
            dst_cidrs = [str(c) for c in r.dst_ips.iter_cidrs()]
            
            src_ports = []
            for p in r.src_ports.iter_cidrs():
                if hasattr(p, 'first'): src_ports.append([p.first, p.last])
                
            dst_ports = []
            for p in r.dst_ports.iter_cidrs():
                if hasattr(p, 'first'): dst_ports.append([p.first, p.last])

            # Lien vers Hyperscan
            hs_id = hs_map[r.id]['hs_id']
            
            # Structure de l'objet binaire
            rule_obj = {
                'id': r.id,
                'proto': r.proto,
                'src_ips': src_cidrs,
                'dst_ips': dst_cidrs,
                'src_ports': src_ports,
                'dst_ports': dst_ports,
                'direction': r.direction,
                'hs_id': hs_id, # Le lien vital !
                'action': r.action
            }
            data_to_serialize.append(rule_obj)
            
        with open(path, 'wb') as f:
            packed = msgpack.packb(data_to_serialize)
            f.write(packed)
            
        print(f"    -> Généré : {filename} ({len(packed)/1024:.2f} KB)")