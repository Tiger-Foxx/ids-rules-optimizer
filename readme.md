# IDS Rules Optimizer: Structural & Semantic Optimization for Network Filtering

**Repository:** [https://github.com/Tiger-Foxx/ids-rules-optimizer](https://github.com/Tiger-Foxx/ids-rules-optimizer)  
**Lead Author:** Tiger-Foxx (Research Project)  
**Technology:** Python 3 (Pre-processing) / C++ (Runtime Engine - *Coming Soon*)  
**Status:** üü¢ Optimization Module (Core) Completed & Validated.

---

## Table of Contents

1.  [Introduction and Scientific Context](#1-introduction-and-scientific-context)
2.  [Objectives and Research Hypothesis](#2-objectives-and-research-hypothesis)
3.  [Global System Architecture](#3-global-system-architecture)
4.  [Optimization Methodology (The Core)](#4-optimization-methodology-the-core)
    *   [4.1. Intelligent Cleaning](#41-intelligent-cleaning)
    *   [4.2. Vector Modeling](#42-vector-modeling)
    *   [4.3. Geometric Fusion (IP Engine)](#43-geometric-fusion-ip-engine)
    *   [4.4. Semantic Fusion (Content Engine)](#44-semantic-fusion-content-engine)
5.  [Technical Details and Algorithms](#5-technical-details-and-algorithms)
6.  [Results and Metrics](#6-results-and-metrics)
7.  [Interface with the C++ Engine](#7-interface-with-the-c-engine)
8.  [Limitations and Accepted Trade-offs](#8-limitations-and-accepted-trade-offs)
9.  [Installation and Usage](#9-installation-and-usage)

---

## 1. Introduction and Scientific Context

### The "Security Stacking" Problem
In modern infrastructures, packets traverse a sequential chain of security devices:
`L3/L4 Firewall` $\rightarrow$ `IDS/IPS (Snort/Suricata)` $\rightarrow$ `WAF (ModSecurity)`

Each device adds:
*   Processing latency (parsing, matching).
*   Memory copies (Zero-Copy impossible on a heterogeneous chain).
*   Redundant CPU consumption (checking 3 times if the IP is not blacklisted).

**Consequence:** A drastic drop in useful throughput (up to -80% observed) and increased latency (Jitter).

### The "Early Rejection" Concept
The idea is to move the blocking decision (`DROP`) as far upstream as possible.
If a packet is destined to be rejected by the IPS (step 2) because of its content, why waste CPU cycles in the Firewall (step 1)?

Our project aims to **mathematically unify** all these rules into a single decision graph, placed at the head of the chain.

---

## 2. Objectives and Research Hypothesis

### Hypothesis
It is possible to compile a heterogeneous set of rules (Firewall + IPS) into a **unified data structure** (Trees + Automata) that is:
1.  More compact (fewer rules to check).
2.  Faster (logarithmic complexity $O(\log N)$ instead of linear $O(N)$).
3.  Strictly equivalent in terms of security (no induced false negatives).

### Why This Isn't Just "Better Snort"?
Engines like Snort optimize *matching* (finding a pattern), but not the *logical structure* of the rules.
*   **Snort:** Reads 10 similar rules as 10 distinct entities.
*   **Our Optimizer:** Merges these 10 rules into 1 complex mathematical entity.

**Consequence:** Our optimized rules **ARE NO LONGER** compatible with Snort. They are intended for a dedicated C++ engine (`FoxEngine`) capable of understanding these merged structures.

---

## 3. Global System Architecture

The project is divided into two distinct components to separate intelligence (slow) from execution (fast).

### A. The Preprocessor (Python) - *This repository*
*   **Role:** Rule compiler ("Offline").
*   **Input:** Standard text files (`snort3-community.rules`).
*   **Processing:** Semantic analysis, Set algebra, Graph theory.
*   **Output:** Optimized binary artifacts and scripts.
*   **Constraint:** No time limit (can take 10 min to compile 10k rules).

### B. The Runtime Engine (C++) - *Future repository*
*   **Role:** Real-time execution ("Online").
*   **Input:** Artifacts generated by Python.
*   **Technologies:** `NFQUEUE` (interception), `Hyperscan` (Intel Regex), `mmap` (binary loading).
*   **Constraint:** Absolute performance (Zero-Copy).

---

## 4. Optimization Methodology (The Core)

Here's how we transform 4000 rules into 300 efficient entities.

### 4.1. Intelligent Cleaning (`src/cleaner.py`)
To guarantee performance, we limit ourselves to **Stateless** filtering (no inter-packet memory) for this PoC.

*   **Removal:**
    *   `flowbits`, `tag`: Require storing state for each flow (memory ++).
    *   `threshold`, `detection_filter`: Require temporal counters.
    *   `byte_test`, `byte_jump`: Require a complex arithmetic VM.
*   **Retention:**
    *   `flow:to_server/client`: Kept as deducible from TCP reassembly.
    *   `flags`, `itype`: Kept (critical for security).

### 4.2. Vector Modeling (`src/models.py`)
We abandon character strings. Each rule becomes a mathematical vector:
$$ R = \{ Proto, \text{SrcIPs}, \text{DstIPs}, \text{SrcPorts}, \text{DstPorts}, \text{Flags}, \text{Patterns} \} $$

*   IPs are managed as **Mathematical Sets** (`netaddr.IPSet`).
*   `$EXTERNAL_NET` becomes `UNIVERSE \setminus \{192.168.0.0/16, ...\}`.
*   This allows calculating exact intersections and unions.

### 4.3. Geometric Fusion (IP Engine): "Hypercube Convergence"
This is our multidimensional spatial reduction algorithm.

#### The Dangerous "Cartesian Product" Problem
Naively merging two rules can create implicit permissions:
```
R1: 10.0.0.1 ‚Üí 192.168.1.10:80 (DROP)
R2: 10.0.0.2 ‚Üí 192.168.1.20:80 (DROP)
Na√Øve Fusion: {10.0.0.1, 10.0.0.2} ‚Üí {192.168.1.10, 192.168.1.20}:80
‚Üí FLAW: Now blocks 10.0.0.1 ‚Üí 192.168.1.20 (not requested!)
```

#### Our Solution: Iterative Unidimensional Fusion
We merge **only one dimension** at a time, keeping all others **strictly invariant**.

**Strict Grouping Signature:**
```python
# To merge Source IPs, we require:
signature = (proto, tcp_flags, icmp_type, dst_ips, dst_ports, src_ports, direction, action, patterns)
# If two rules have this identical signature ‚Üí We can merge their src_ips safely
```

**Convergence Algorithm (Fixed Point):**
```
Iteration 1:
  - Src_IP Pass:  3185 ‚Üí 3150 rules (-35)
  - Dst_IP Pass:  3150 ‚Üí 3145 rules (-5)
  - Dst_Port Pass: 3145 ‚Üí 3140 rules (-5)
  - Src_Port Pass: 3140 ‚Üí 3137 rules (-3)
  Total: -48 rules

Iteration 2:
  - Src_IP Pass:  3137 ‚Üí 3137 rules (0)
  ‚Üí Fixed Point reached: Cannot merge further without risk.
```

**Mathematical Guarantee:** The algorithm always converges in $O(k)$ iterations where $k$ is the number of dimensions (typically 2-4 iterations).

### 4.4. Semantic Fusion (Content Engine): "Hybrid Trie Factorization"
This is the attack signature compression algorithm using lexical analysis.

#### Hybrid Architecture (Security + Performance)
The module separates rules into two categories to avoid breaking complex inspection logic.

**1. Simple Rules (Single Pattern) ‚Üí Trie Factorization**
```
Input:
  R1: content:"admin.php"    (IP: 10.0.0.1 ‚Üí 192.168.1.50:80)
  R2: content:"admin.html"   (IP: 10.0.0.2 ‚Üí 192.168.1.50:80)
  R3: content:"admin_panel"  (IP: 10.0.0.3 ‚Üí 192.168.1.50:80)

Algorithm:
  1. Trie Construction:
       [a][d][m][i][n]
                   ‚îú‚îÄ [.][p][h][p] (R1)
                   ‚îú‚îÄ [.][h][t][m][l] (R2)
                   ‚îî‚îÄ [_][p][a][n][e][l] (R3)
  
  2. Common Prefix Detection: "admin"
  
  3. Regex Factorization:
     Optimized Pattern: /admin(\\.php|\\.html|_panel)/
     Merged IP: {10.0.0.1, 10.0.0.2, 10.0.0.3} ‚Üí 192.168.1.50:80

Output: 1 rule instead of 3 (-66%)
```

**2. Complex Rules (Multi-Patterns) ‚Üí Strict Hashing**
```
Input:
  R1: content:"POST"; content:"/admin/delete"; http_method;
  R2: content:"GET";  content:"/admin/delete"; http_method;

Decision:
  ‚Üí Do NOT merge (different pattern sequences)
  ‚Üí Risk of false positive if only "/admin/delete" is kept

Output: 2 rules kept (Security priority)
```

#### Tuning Parameters
```python
self.min_prefix_len = 4  # Only factorize if prefix ‚â• 4 characters
                         # Avoids: "get" ‚à™ "got" ‚Üí /(ge|go)t/ (inefficient)
```

#### Measured Real Gain
On `snort3-community.rules`: **3137 ‚Üí 1835 rules (-41.5%)** thanks to the Trie.

---

## 5. Technical Details and Algorithms

### Security Management (Avoiding the "Cartesian Product")
A classic error in firewall optimization is merging Sources and Destinations simultaneously.

**Classic Error Example:**
```
R1: A ‚Üí B (Port 80)
R2: C ‚Üí D (Port 80)
Na√Øve Fusion: {A,C} ‚Üí {B,D} (Port 80)
‚Üí FLAW: Allows A ‚Üí D and C ‚Üí B (never requested!)
```

**Our Protection:**
```python
# In ip_engine.py, line 77-85
if target == 'src_ip':
    # To merge Sources, we include dst_ips in the signature
    sig = (proto, tcp_flags, dst_ips, dst_ports, src_ports, ...)
    # ‚Üí We merge Sources ONLY if Destinations are identical
```

**Proof by Construction:**
- The algorithm iterates on one single dimension at a time
- Other dimensions are **frozen** in the hash signature
- A fusion `{A,C} ‚Üí {B,D}` is **mathematically impossible** because B‚â†D causes the grouping to fail

### Data Architecture: Why `netaddr.IPSet`?
Instead of IP lists, we use a mathematical library.

**Advantages:**
```python
# Automatic CIDR merging for adjacent ranges
ips = IPSet(['192.168.1.0/24', '192.168.2.0/24'])
# ‚Üí Auto-optimized to 192.168.0.0/23 (memory gain)

# Implicit overlap management
rules = [
    IPSet(['10.0.0.0/8']),    # Broad Rule
    IPSet(['10.1.1.0/24'])    # Specific Rule (subset)
]
union = IPSet.union(*rules)
# ‚Üí Automatic subsumption: 10.0.0.0/8 absorbs 10.1.1.0/24
```

**Complexity:** Union/intersection operations are $O(\log N)$ thanks to the internal tree of `netaddr`.

### The "MessagePack" Format
Why not JSON or XML?

**Performance Comparison:**
| Format | File Size | Parse Time (C++) | Binary Support |
|--------|-----------|------------------|----------------|
| JSON   | 2.4 MB    | ~150 ms          | ‚ùå (Base64 required) |
| XML    | 3.8 MB    | ~280 ms          | ‚ùå              |
| **MessagePack** | **0.9 MB** | **~8 ms** | ‚úÖ (native) |

**Concrete Example:**
```python
# Python (Writing)
data = {
    "rule_id": 1,
    "src_ips": ["192.168.1.0/24", "10.0.0.1"],
    "pattern_id": 42,
    "action": "drop"
}
msgpack.dump(data, f)
```

```cpp
// C++ (Reading - Zero-Copy)
msgpack::object_handle oh = msgpack::unpack(buffer, size);
auto rule = oh.get().as<Rule>(); // Instantaneous
```

**Critical Advantage:** The C++ engine can `mmap()` the file directly into RAM without parsing. Pointers point into the mapped file (saves memory copies).

---

## 6. Results and Metrics

**Test Dataset:** `snort3-community.rules` (2025 Version)

### Complete Reduction Pipeline

| Phase | Input | Output | Reduction | Technique |
|-------|-------|--------|-----------|-----------|
| **Raw** | 4017 | - | - | Original file |
| **1. Cleaning** | 4017 | 3185 | -20.7% | Stateful Elimination |
| **2. Parse** | 3185 | 3185 | 0% | Vectorization |
| **3. IP Fusion** | 3185 | 3137 | -1.5% | Hypercube Convergence |
| **4. Pattern Fusion** | 3137 | 1835 | -41.5% | Trie Factorization |
| **TOTAL** | **4017** | **1835** | **-54.3%** | Complete pipeline |

### Breakdown by Type

| Category | Count | Destination | Comment |
|----------|-------|-------------|---------|
| **Pure Firewall** | 85 | `firewall.sh` | Kernel Offloading (iptables) |
| **IPS (Inspection)** | 1750 | `patterns.txt` + `msgpack` | Requires Hyperscan |

### Qualitative Analysis

**Why only -1.5% in Phase 3 (IP)?**
- Snort Community rules are already very specific (few IP duplicates).
- Most rules target `$HOME_NET` ‚Üí `$EXTERNAL_NET` (identical signature, but different patterns).
- IP gain will be much more significant on enterprise rules (redundant IP Blacklists).

**Why -41.5% in Phase 4 (Patterns)?**
- Many attack variants (e.g., 50 rules for "SQLi" with similar patterns).
- The Trie efficiently factorizes these attack families.

### Performance Projection (Theoretical Model)

Considering a na√Øve linear complexity $O(N)$ for matching:
```
Baseline:  3185 rules ‚Üí 3185 comparisons/packet
Optimized:  1835 rules ‚Üí 1835 comparisons/packet
CPU Gain: -42.4% (proportional to the number of rules)
```

**In Reality (with tree structures):** The gain will be higher because:
- Firewall rules (85) execute in $O(1)$ via `iptables` (kernel hash table).
- Hyperscan patterns benefit from factorized regex (fewer state transitions).

---

## 7. Interface with the C++ Engine

The C++ engine (`FoxEngine`) is designed to be "dumb and fast". It doesn't think, it executes the orders contained in the artifacts.

### The 3 Delivered Files

1.  **`firewall.sh` (Bash Script)**
    *   **Role:** Kernel Offloading.
    *   **Action:** Configures `iptables` to silently block known IPs/Ports before they even reach user space.
    *   **Gain:** Zero CPU cost for the application.

2.  **`patterns.txt` (Text)**
    *   **Role:** Hyperscan database.
    *   **Format:** `ID:/regex/flags`.
    *   **Content:** Factorized regex (e.g., `1:/virus(A|B)/`).

3.  **`rules_config.msgpack` (Binary)**
    *   **Role:** Logical Brain.
    *   **Content:** Decision trees. "If Src IP $\in$ {A,B,C} and Port=80 $\rightarrow$ Then scan with pattern ID 1".
    *   **Usage:** Loaded into RAM at startup.

### Comparison Protocol (Benchmark)
To prove the effectiveness of our optimization, we will use the **SAME C++ engine** with two configurations:

1.  **Baseline Mode (Control):**
    *   Deactivate fusion in Python.
    *   Output: 3185 unitary rules.
    *   C++ loads 3185 entries.
2.  **Optimized Mode (Experiment):**
    *   Activate fusion.
    *   Output: 1835 merged rules.
    *   C++ loads 1835 entries.

**Measurement:** Difference in throughput (Gbps) and Latency (¬µs) on test traffic (e.g., `tcpreplay`). The difference will be purely attributable to our algorithm.

---

## 8. Limitations and Accepted Trade-offs

1.  **Snort Incompatibility:** Our optimized rules can no longer be read by Snort. This is an accepted choice to break performance limits.
2.  **Loss of Granular Traceability:** If a packet is blocked by a merged "Web Malware" rule, we won't necessarily know if it was "Malware A" or "Malware B".
    *   *Justification:* In operational defense, the important thing is to block the threat, not necessarily to know its exact baptism name at the microsecond level.
3.  **Stateless Scope:** Complex attacks requiring long-term temporal correlation (e.g., slow Brute Force) are not covered by this PoC.

---

## 9. Installation and Usage

### Prerequisites
*   **Python:** 3.10+ (for f-strings and pattern matching)
*   **Libraries:**
    ```bash
    pip install netaddr msgpack tqdm
    ```
    - `netaddr`: IP set algebra (automatic CIDR merge)
    - `msgpack`: High-performance binary serialization
    - `tqdm`: Progress bars (optional, cosmetic)

### Quick Installation
```bash
git clone https://github.com/Tiger-Foxx/ids-rules-optimizer.git
cd ids-rules-optimizer
pip install -r requirements.txt
```

### Standard Usage
```bash
# 1. Download Snort Community rules (example)
wget https://www.snort.org/downloads/community/snort3-community-rules.tar.gz
tar -xzf snort3-community-rules.tar.gz
cp snort3-community-rules/snort3-community.rules inputs/

# 2. Run optimization
python main.py --rules snort3-community.rules

# 3. Retrieve artifacts
ls -lh outputs/
# ‚Üí firewall.sh (Kernel Script)
# ‚Üí patterns.txt (Hyperscan Base)
# ‚Üí rules_config.msgpack (Binary Logic)
```

### Advanced Options
```bash
# Disable Stateful cleaning (keep flowbits, etc.)
python main.py --rules custom.rules --no-clean

# Debug Mode (displays detailed fusions)
python main.py --rules test.rules --verbose

# Export JSON instead of MessagePack (for debug)
python main.py --rules test.rules --format json
```

### Output Structure

**1. `firewall.sh` - iptables Script**
```bash
#!/bin/bash
# Auto-generated by IDS Rules Optimizer
# Date: 2025-11-22

# Rule 1: IP Reputation Blocking (Malware C2)
iptables -A INPUT -s 192.0.2.0/24 -j DROP
iptables -A INPUT -s 198.51.100.0/24 -j DROP

# Rule 85: Automated Scanner Blocking
iptables -A INPUT -p tcp --dport 22 -m recent --name SSH --rcheck --seconds 60 --hitcount 4 -j DROP
```

**2. `patterns.txt` - Hyperscan Base**
```
# Format: ID:/regex/flags
1:/admin\.(php|html|asp)/i
2:/\x90{10,}/  # NOP Sled Detection
3:/(union|select).+(from|where)/i  # SQL Injection
```

**3. `rules_config.msgpack` - Binary Logic**
```python
# Example Structure (human format, actual=binary)
{
  "rules": [
    {
      "id": 1,
      "src_ips": ["0.0.0.0/0"],  # ANY
      "dst_ips": ["192.168.1.50/32"],
      "dst_ports": [80, 443],
      "proto": "tcp",
      "pattern_ids": [1, 3],  # References to patterns.txt
      "action": "alert"
    }
  ]
}
```

### Integration with the C++ Engine (Future)
```cpp
// Pseudo-code of the runtime engine
#include <msgpack.hpp>
#include <hs/hs.h>

int main() {
    // 1. Load logic
    auto rules = msgpack::unpack(mmap("rules_config.msgpack"));
    
    // 2. Compile Hyperscan
    hs_database_t* db = compile_from_file("patterns.txt");
    
    // 3. Hook NFQUEUE
    nfq_handle* h = nfq_open();
    nfq_create_queue(h, 0, &packet_callback, nullptr);
    
    // 4. Infinite loop
    while (1) {
        nfq_handle_packet(h); // Inspects each packet
    }
}
```

### Post-Optimization Verification
```bash
# Count rules before/after
wc -l inputs/snort3-community.rules
# ‚Üí 4017

wc -l outputs/patterns.txt
# ‚Üí 1750

# Verify MessagePack validity
python -c "import msgpack; print(msgpack.unpack(open('outputs/rules_config.msgpack', 'rb')))"
# ‚Üí Should display structure without error
```

---

*This project is an academic contribution to the study of high-performance data structures for cybersecurity.*